Write Points What you Learned in Course
----------------------------------------
Experience with Linux Server admin activities like user, service, package, network and process management.
Experience in using Linux editors like vim.
Experience in using public and private, configuring them to the servers..

Process Management 
----------------------
process --> a sequence of steps to follow to complete a task...

Outside, Whatever the business may be IT or Non-IT ticketing system is there.

Why ticketing system? that is a process to serve the customers. 

ticketing system means every order will get one order id /ticket id. customers can easily see the order-id and get the order. end of the days business will also will have an clarity how many orders placed and served on different dates and their values etc.

in the same way linux also process management is important.

in linux/windows (any operations system) everything is process.

Linux creates process id for everything...

PID --> process instance id (Operating Systems tracks Tasks using PID. How many tasks completed and pending)

If a task is big, do you think one process is enough?

We create subtasks...

Acc Manager, Team Manager, Lead, Senior, Junior, Trainee  --> In a Team also we have

Trainee reports to Junior, Junior reports to Senior

here Trainee is child, his parent is Junior

PID, PPID (PID reports to PPID) (Parent Process Instance Id)

ps (used to check the status of active processes on a system and display technical information about them)

 PID TTY          TIME CMD
1338 pts/0    00:00:00 bash
1636 pts/0    00:00:00 ps

1338 pts/0    00:00:00 bash --> here bash is nothing but the terminal which we used to connect to the server this process will run till we use terminal to connect to the server.

1636 pts/0    00:00:00 ps --> this is the command which we ran now.

we can clearly see linux will create a pid for even a command and then show us the results. ultimately, linux has to track everything what has happened inside the server.

from this we can understand linux will create process instance id for everything whatever we do.

here, we can see only two process. these two are process from this session. if you want to see everything then the command is
ps -ef --> all process in linux

UID          PID    PPID  C STIME TTY          TIME CMD
root           1       0  0 05:23 ?        00:00:01 /usr/lib/systemd/systemd --switched-root --system --deserialize 31
root           2       0  0 05:23 ?        00:00:00 [kthreadd]
root           3       2  0 05:23 ?        00:00:00 [rcu_gp]
root           4       2  0 05:23 ?        00:00:00 [rcu_par_gp]
root           5       2  0 05:23 ?        00:00:00 [slub_flushwq]
root           6       2  0 05:23 ?        00:00:00 [netns]
root           8       2  0 05:23 ?        00:00:00 [kworker/0:0H-events_highpri]

for process with ppid 0 they are the main or parent process. process should start from somewhere not every process will have a parent. ppid 0 means they are the main process. from there every process will have a parent. see using ps -ef only 1st and second will have no parent remaing all process will have a parent.

These are very important. if we are running a service like nginx. application is nothing but a service inside a linux for that also we will have a pid. if pid is there that means service is running. if pid is not there it means service is not running. in trobuleshooting these will be really useful.

foreground and background

foreground process blocks the terminal until it completes

& will take the process into background

for example if you give command
sleep 20 (you cannot do anything for 20 seconds in terminal because it is running in foreground)
sleep 20 & (& ampersand will take the process into background)

ps -ef 
ec2-user    3563    3346  0 07:48 pts/0    00:00:00 sleep 20 [you can see this at the end after 20 seconds this pid will be exited]
[1]+  Done                    sleep 20 [after finish you will get]


how to check from a list of process whether a process is running or not
ps -ef | grep nginx [ with this command you can see nginx process is running or not]

ps -ef | grep sleep
ec2-user    3590    3346  0 07:51 pts/0    00:00:00 sleep 20
ec2-user    3596    3346  0 07:52 pts/0    00:00:00 grep --color=auto sleep [this line is coming due to grep command we used]

ps -ef | grep sleep | grep -v grep [here we are telling to remove grep command in result]
ec2-user    3633    3346  0 07:55 pts/0    00:00:00 sleep 20

with this command we can grep ngix, java etc.

ps -ef | grep nginx

some times process is runnig but service is stuck.
when a service stuck, you need to restart

To restart the service kill the existing process, and restart the service....

ps -ef | grep sleep | grep -v grep
ec2-user    3658    3346  0 08:00 pts/0    00:00:00 sleep 20

kill 3658 [kill pid] [we cannot use parent process instance id] 
[1]+  Terminated              sleep 20

some times kill will not work then you can kill forcefully
kill -9 3708 [-9 is for forcefully]
[1]+  Killed                  sleep 20

for kill we get terminated. for kill -9 we get killed.

kill vs kill -9
---------------
kill -> request to end --> graceful termination
kill -9 --> order to end --> forceful termination

top --> all running process with CPU and RAM

top command will give date dynamically. if will keep on changing and display all the values dynamically.

ctrl + c --> to come out of top

Network management
-------------------
netstat command is a network utility that provides information about network connections, routing tables, interface statistics, and more. It's commonly used for troubleshooting and monitoring network performance. netstat means network statistics.

How to check a port is opened or not in linux
netstat --> This shows all active connections and listening ports.
netstat -l --> Lists all ports that are currently listening for incoming connections.

netstat -lt --> This command is useful for checking which TCP services are currently running and accepting connections on your machine
netstat: The network statistics command.
-l: This option shows only the listening sockets.
-t: This option specifies that only TCP connections should be displayed.

netstat -ltnp --> listdown the tcp opened ports and their PID (Transmission Control Protocol) (internet works on tcp protocol)
netstat: The network statistics command.
-l: Show only listening sockets.
-n: Display addresses and port numbers in numeric form instead of resolving hostnames and service names.
-t: Show TCP connections only.
-p: Show the PID (Process ID) and name of the program to which each socket belongs.

for normal user Process ID will not be shown. if you use sudo netstat -lntp then you can see PID also.

if applications is running means for example nginx is running means which port you should check whether opened or not using netstat -lntp? -- Port no 80
if port no 80 is opened then you can say nginx is running. in the same way 3306 etc. if port no is not opened means we can say the application is not running. This is also one of trobuleshooting command to check whether application is running or not.

netstat -lntp
Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name
tcp        0      0 0.0.0.0:22              0.0.0.0:*               LISTEN      -
tcp6       0      0 :::22                   :::*                    LISTEN      -

above port no 22 is opened means ssh is running.

still there are lot networking trobuleshooting command ping, telnet we will discuss them slowly.

Expenses Project
-------------------
when app is getting started [provision of application or starting of the application]
--------------------------------------------------------------------------------------
1. DB should be ready [Raw items]
2. Chef should be ready [Backend]
3. Waiter [Frontend]

if database is ready then backend can perform some operations on it. if backend is ready then fronted process its requests and get response from backend.

termination of application [closing hotel in the night]
--------------------------------------------------------
1. LB
2. frontend
3. backend
4. DB

first waiter we will close then chef will not get new orders. later we will close chef if chef is closed then they will decide whether to throw or keep left over items.

This is the process of starting and termination  of application without errors.


from now on we will username and password based not key based. for public servers in projects they will go with key based. for secure environment within the project we will go with username and password.

RHEL9 -> Latest redhat enterprise OS -> in banking companies 
CentOS 9 -> opensource -> startups use this

RHEL9 == CentOS9

RHEL
-----
ec2-user -> username
DevOps321 -> password
Browse AMI --> devops-practice --> us-east-1 region (available only here)

CentOS 9
--------
centos --> username
DevOps321 --> password
Browse AMI --> devops-practice --> us-east-1 region (available only here)

for this ami's key pair is not needed becuase already configured with username and password.

make 3 instance of RHEL 9 for our project in AWS and Launch them.

image = we + our surroundings
AMI = Bare OS + packages you installed

use AMI you will get all packages

putty and super putty
mobaxterm --> alternative to putty and super putty

RDBMS --> relational database management system
Table and column based data

USER
------
ID	USERNAME	PASSWORD		MobileNumber
1	joindevops	joindevops321	6281937079

ADDRESS
-------
ID	USERID	AddressLine1	AddressLine2	City
1	1	    	sanath nagar	stree3		HYD

mysql --> 3306

username --> root


Backend
-------------------
Program needs that runtime(Software)

installed nodejs

usually applications can be run by system/functional/daemon users...

create a seperate folder for application is a good practice

application is somewhere in internet, developer is giving the location

npm install --> install the libraries/dependencies

yum install nginx -y --> automatic download and installation
systemctl start nginx --> runs the service automatically

systemctl service.....

application is manually configured by us, you can't run systemctl commands to start our application....

systemctl will give an option to configure our application as automatic start/stop and restart

/etc/systemd/system --> create your service file in this directory..

backend.service --> .service is also mandatory

[Unit]
Description=amazon-ssm-agent
After=network-online.target

[Service]
Type=simple
WorkingDirectory=/usr/bin/
ExecStart=/usr/bin/amazon-ssm-agent
KillMode=process

# Restart the agent regardless of whether it crashes (and returns a non-zero result code) or if
# is terminated normally (e.g. via 'kill -HUP').  Delay restart so that the agent is less likely
# to restart during a reboot initiated by a script. If the agent exits with status 194 (reboot
# requested), don't restart at all.
Restart=always
RestartPreventExitStatus=194
RestartSec=90

[Install]
WantedBy=multi-user.target


java/npm install --> it is configured already

service/application --> public access this, this should be running

:wq --> write and quit
:wq! --> force write
:q! --> force

32:44