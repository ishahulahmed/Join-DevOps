Session Overview
-----------------
a) Docker Volumes
b) Docker best practices

volumes:
- unnamed
- named

unnamed means we will create volume in local system and connect using -v host-path:container-path
named volumes means we will create volumes using docker commands and the life cycle of volume will be taken care by docker

-v host-path:container-path

docker run -d -p 80:80 -v /home/ec2-user/nginx-data:/usr/share/nginx/html nginx
host path we need to give completely for unnamed volume creation because docker will not take relative paths.

http://35.171.84.109:80 (it will not work because nginx-data folder have no files 
cd nginx-data
echo "<h1>Hi, I am Learning unnamed volumes</h1>" > index.html
now, it will work because container is referring to the local directory (nginx-data). i.e directory inside the server. you can put even your entire website here.

images size should be less docker best practise. let's see our expense-docker images size.
for i in mysql backend frontend; do cd $i; docker build -t $i:v1.0 . ; cd .. ; done

REPOSITORY   TAG       IMAGE ID       CREATED              SIZE
frontend     v1.0      9b6921366a48   7 seconds ago        189MB
backend      v1.0      65323a9f4f8c   11 seconds ago       1.11GB
mysql        v1.0      c9e0d38cacd8   About a minute ago   572MB

here frontend or more in size we will decrease there size using alpine because it is the most small image. we will not play with mysql since it is stateful application. we will only make changes to stateless applications in such a way that image size should less and it should be fully in working condition. in quest for reducing the size we should not compromise on it's practical application. both, should be balanced.

docker volume create mysql (we creating volume mysql since our docker-compose.yaml have external true for mysql)
docker compose up -d 
so our expense-app is running. but, we need to optimise this by using alpine linux images no we will change our code according in dockerfiles of respective images.

FROM node:20.16.0-alpine3.20 (node.js is 20 but os apline on which node 20 is working)
RUN addgroup -S expense && adduser -S expense -G expense (we need to create group and then add user to it in alpine OS not conform)
cd backend
docker build -t backend:v1.0 (since dockefile is changed we need to build new image)
backend      v1.0      293ddf11f62b   11 seconds ago   152MB
now image size 152MB previous 1.1GB. Now test the application.

1GB app 

single flat 2400 sqft --> only one room --> one family (PG rooms famous it doesn't mean we can accomodate a family in single room of pg)
in the samey way since containerisation is popular we can't put a  big app in a container. if you are getting an image size more than 500MB. First reduce the size of image. change the design of the application. but, people are forcing to using to use big apps in containers. since, management also do not have any experience they are also proceedign this way. but, we should always follow best practises.

6GB apps are also running in containers

Multi stage builds --> Java apps (Mostly Java Applications are Mulit Stage Builds)

JDK --> Java development kit
JRE --> Java runtime environment

JDK > JRE

JDK = JRE + development tools

Developers develop java apps in JDK environment, once you get build package. no need to dev environment


app code --> compile[JDK] --> java bytecode(build file) .jar, .war [JDK]  (Microservies mostly .jar)

run bytecode --> app is up [JRE]

ChatGPT
--------
a) Binary Code is a broader term that refers to any data in binary form. This includes machine code as well as other forms of binary-encoded data.
b) Machine Code is a specific type of binary code that directly interacts with the hardware. It is usually represented in binary or hexadecimal format and 
   consists of instructions that the CPU can execute directly.
c) Bytecode is a intermediate code that is not directly executed by the hardware but requires a virtual machine or interpreter to run. It is usually more 
   portable than machine code

Bytecode
---------
a) Description: Bytecode is a form of intermediate code that is typically generated by compilers for languages that run on a virtual machine (like Java 
                bytecode for the JVM or Python bytecode for the Python interpreter). It is a set of instructions that is more abstract than machine code and 
                is meant to be executed by a virtual machine rather than directly by the hardware.

b) Context: Bytecode is language-specific and designed to be portable across different platforms, requiring a runtime environment (e.g., JVM, Python 
            interpreter) to execute.

Bytecode is not the same for every language. Bytecode is a form of intermediate code used by some programming languages to achieve platform independence and optimize execution. Different languages have their own specific bytecode formats, and each language's bytecode is designed to work with its particular runtime environment. Here's a bit more detail:

1) Java Bytecode:
   a) Description: Java bytecode is a platform-independent intermediate code generated by the Java compiler (javac) from Java source code. It is executed by 
                   the Java Virtual Machine (JVM). Java bytecode is specific to the Java language and the JVM.

2) Python Bytecode:
   a) Description: Python bytecode is generated by the Python interpreter when you run a Python script. It is an intermediate representation of your Python  
                   code and is executed by the Python Virtual Machine (PVM). Python bytecode is specific to the Python language and the Python runtime
                   environment.

3) C# Bytecode (Intermediate Language - IL):
   a) Description: In the .NET ecosystem, C# (and other .NET languages) are compiled into Intermediate Language (IL) or Common Intermediate Language (CIL) 
                   bytecode. This IL bytecode is executed by the .NET Common Language Runtime (CLR).

4) Other Languages:
   a) Description: Many other languages use their own form of bytecode. For example, languages like Kotlin (which also runs on the JVM) generate bytecode 
                   that is compatible with the JVM, while languages like Scala also generate JVM bytecode but include features specific to their own     
                   language constructs.
Key Points to Note:
-------------------
a) Language-Specific: Bytecode is tailored to the specifics of the language and its runtime. Different languages have different bytecode formats and  
                      execution models.
b) Platform Independence: The primary purpose of bytecode is to provide a platform-independent way to execute code. The same source code can be compiled 
                          into the same bytecode and then executed on any platform with the appropriate runtime environment.
c) Optimizations: Different runtime environments might include optimizations or variations in how they handle bytecode execution, such as JIT compilation,  
                  which can affect performance but not the fundamental nature of the bytecode.

JRE
----
The Java Runtime Environment (JRE) does not compile code; it executes bytecode. Here's a clearer breakdown of the roles of different components in the Java ecosystem:

1) Compilation Phase:
   a) Java Compiler (javac): When you write Java source code (.java files), you need to compile it into bytecode. This is done by the Java compiler, javac. 
                             The compiler takes the source code and translates it into bytecode (.class files), which is a platform-independent intermediate 
                             representation of your code.

2) Execution Phase:
   a) Java Runtime Environment (JRE): The JRE is responsible for running the compiled bytecode. It does not compile code; instead, it includes the Java 
                                      Virtual Machine (JVM) that interprets or compiles the bytecode into machine code specific to the host operating 
                                      system.
3) Java Virtual Machine (JVM):
   a) Interpreter: The JVM can execute bytecode directly using an interpreter. This means it reads and executes the bytecode instructions one at a time.
   b) Just-In-Time (JIT) Compiler: For better performance, the JVM often uses a Just-In-Time (JIT) compiler to translate bytecode into native machine code 
                                   at runtime. This native code is then executed directly by the hardware, which can significantly speed up execution 
                                   compared to interpretation alone.

In summary, the JRE does not compile Java code. It runs bytecode produced by the Java compiler and can use the JVM to interpret or compile bytecode into machine code as needed.

Roboshop-shipping
---------------------
Aritficat Extension in node .zip but in java .jar

after npm install in nodejs node_modules directory but for java we will get target directory

a) node_modules directory is a folder typically found in projects that use Node.js for server-side JavaScript development or front-end development workflows 
   involving tools like npm (Node Package Manager) or Yarn.
b) It stores all the external libraries and dependencies that your project uses. These can include frameworks, libraries, modules, utilities, etc., needed 
   to run your application.
c) node_modules is a crucial directory in Node.js projects where all external dependencies are stored, ensuring that your project can access and use the  
   necessary libraries and tools specified in your project configuration (package.json). (like target folder in java)

package.json and pom.xml serve similar high-level purposes of managing dependencies and defining project configurations, but they do so within their own ecosystems and for their respective programming languages (JavaScript/Node.js vs Java). They reflect the different conventions and needs of each ecosystem rather than being directly comparable in terms of functionality beyond dependency management and project configuration.

in target folder there will be jar file if we run that jar file then application will run. that is the file we are looking you can run it directly from dockerfile instructions.
-rw-r--r-- 1 root root 41486756 Jul 28 11:13 shipping-1.0.jar

In the context of Dockerfiles, FROM maven and FROM maven as build are both instructions used to define the base image for building Docker images related to Maven-based projects, but they serve slightly different purposes:

1) FROM maven: This line specifies that the Docker image is based directly on the official Maven image available on Docker Hub. This image typically 
               includes a basic Maven setup with Java, allowing you to run Maven commands directly within your Docker container. For example:
               removing unnecessary files is best practise.
                 
               FROM maven

               # Your Dockerfile instructions here

               Here, you can execute Maven commands such as mvn clean install directly within your Docker container.

2) FROM maven as build: This syntax introduces a multi-stage build in Docker. In a multi-stage build, you can use multiple FROM instructions in a single 
                        Dockerfile. Each FROM instruction starts a new stage of the build. The as build part assigns a name (in this case, build) to the 
                        build stage, which you can refer to later in the Dockerfile.

                        FROM maven as build

                        # Build stage: use this stage to build your Maven project
                        COPY pom.xml .
                        RUN mvn dependency:go-offline

                        COPY src ./src
                        RUN mvn package

                        # Start a new stage to create the runtime image
                        FROM openjdk:11-jre-slim
                        COPY --from=build /target/your-app.jar /app.jar

                        CMD ["java", "-jar", "/app.jar"]

                       In this example:
                       The FROM maven as build line starts the first stage of the build, where Maven is used to compile and package your application.
                       Later in the Dockerfile (FROM openjdk:11-jre-slim), another FROM instruction starts a new stage for creating the runtime image. The  
                       COPY --from=build instruction copies the built artifact from the build stage into the runtime image.
Key Differences:
-------------------

a) Single Stage (FROM maven): This approach creates a single Docker image where Maven is used both for building your application and potentially for running 
                              it.

b) Multi-Stage (FROM maven as build): This approach separates the build process (compiling, testing, packaging) from the final runtime image. It helps  
                                      reduce the size of the final Docker image by discarding unnecessary build dependencies that are only needed during the 
                                      build phase.
Use Cases:
-----------
a) Use FROM maven for simple cases where you just need Maven to build and run your application within a single Docker image.

b) Use FROM maven as build for more complex scenarios where you want to optimize your Docker image size by separating the build environment (Maven) from the 
   runtime environment (e.g., JDK or JRE).

By using Multi Stage Build we can Reduce the size of the image.

if use docker build command it should load all the files the workspace for atleast context purpose whether it will use them or not so use dockerignorefile.
so, please don't keep unnecessary files in the workspace. if you need them in workspace but you don't use for building image use dokcerignore file.

layer1 --> FROM nginx
layer2 --> FROM nginx+RUN rm -rf /usr/share/nginx/html/index.html --> create image

create layer2 container from layer2 image

layer3 image = layer2+RUN rm -rf /etc/nginx/nginx.conf

create layer3 container from layer3 image

layer4 image=layer3+RUN rm -rf /etc/nginx/conf.d/default.conf


FROM nginx
RUN rm -rf /usr/share/nginx/html/index.html
RUN rm -rf /etc/nginx/nginx.conf
RUN rm -rf /etc/nginx/conf.d/default.conf
USER nginx


FROM nginx
RUN rm -rf /usr/share/nginx/html/index.html